\chapter{Regresión Lineal Múltiple}

\section{El problema}
En esta sección veremos como hacer una regresión lineal múltiple usando Julia. El modelo de regresión lineal clásico es 

\valinline{No se porque no sale el beta 0}

\begin{equation} \label{rlm_eq}
    \begin{aligned}
    y_i = \beta_i X_{i1} + \dots + \beta_k X_{ik} + \epsilon_i \text{, para } i = 1, \dots, n \text{ \cite[p.~146]{regression_other_stories}}
    \end{aligned}
\end{equation}

donde los errores son independientes y siguen una distribución normal con media 0 y desviación estándar $\sigma$. En este caso, $y_i$ se refiere al nivel i-ésimo del regresor; $x_{ij}$ es el j-ésimo regresor al i-ésimo nivel; y $\beta_j$ es el coeficiente del j-ésimo regresor. \val{Esto es de las notas del profesor Barrios}


De manera matricial, la ecuación \ref{rlm_eq} se puede escribir como \begin{equation*}
    \begin{aligned}
    y_i = X_i \beta + \epsilon_i \text{, para } i = 1, \dots, n
    \text{ \cite[p.~146]{regression_other_stories}}
    \end{aligned}
\end{equation*}

donde $X$ es una matriz de $n \times k$ donde su i-ésimo renglón es $X_i$. 

\section{Los datos}
Tomando en cuenta que los modelos estadísticos se utilizan como un reflejo de la realidad decidí usa los datos del Censo de Población y Vivienda 2020. Los datos son publicados por el Instituto Nacional de Estadística y Geografía (INEGI) y se pueden encontrar en la página \url{https://www.inegi.org.mx/programas/ccpv/2020/default.html}. 


El propósito del Censo 2020 es producir información sobre el volumen, la estructura y la distribución espacial de la población, así como de sus principales características demográficas, socioeconómicas y culturales; además de obtener la cuenta de las viviendas y sus características tales como los materiales de construcción, servicios y equipamiento, entre otros \val{agregar referencia de la página del INEGI}. Los resultados del Censo que estoy utilizando vienen de las respuestas al llamado cuestionario ampliado cuyas 103 preguntas resultan en alrededor de 200 variables de estudio. Asimismo, el Censo fue aplicado a 4 millones de viviendas a lo largo de la República Mexicana que dio resultado a la obtención de información de más de 15 millones de personas.

En este caso, elegí un tema que es de interés para todos los adultos: los ingresos. Más específicamente, quiero usar la RLM para ver como afectan diferentes variables al ingreso de cada persona. Usualmente, es trabajo del estadístico construir un modelo desde cero usando una combinación de lógica, referencias y experiencia. En este caso, el modelo final que ajusté es 
\begin{equation} \label{modelo_final}
    \begin{aligned}
    ingresos \sim horas_{trabajadas} + sexo + edad + escolaridad + entidad_{residencia} + \\ posicion_{laboral} + alfabetismo + aguinaldo + vacaciones + servicio_{medico}
    \end{aligned}
\end{equation}


\section{Planteamiento del problema}
El Censo es el conjunto de cuestionarios que se le aplican a distintas personas en México. Por eso, antes de comenzar a ajustar los datos, hay que hacer un filtro. Para hacer este filtro y saber que significa cada variable así como sus posibles respuestas, descargué el diccionario del cuestionario ampliado que se encuentra en \url{https://www.inegi.org.mx/programas/ccpv/2020/default.html#Microdatos} dentro del apartado \textsf{Documentación de la base de datos}. El diccionario es de suma importancia ya que proporciona el significado de los códigos que usaron para pasar las respuestas de una hoja de papel a una base de datos. 


La información de los resultados del Censo está dividida en tres partes: Viviendas, Personas y Migrantes. En esta ocasión, utilicé solamente la base de datos de Personas ya que contiene toda la información que necesito. 


La cantidad de datos con la que estoy trabajando es enorme por lo que en primer lugar seleccione solamente las columnas que necesito. Después, puse los siguientes filtros 

\begin{enumerate}
    \item 
    \item Obtuve solamente las personas tienen un trabajo remunerado. Es decir, no consideré las personas que
    se ocupan de las labores del hogar, son jubiladas o pensionadas, son estudiantes o tienen alguna incapacidad que les impide trabajar. 
    
    \item Descarté a las personas que viven y trabajan fuera de la República Mexicana. 
    
    \item Obtuve solamente a las personas que especificaron horas trabajadas e ingreso ganado.
    
    \item Además, para las variables que representan los regresores quité a todas las personas que respondieron a alguna de esas preguntas con \textsf{No específicado}. 
\end{enumerate}

Finalmente, ya que la base se reduce considerablemente y todo el proceso dura alredodr de 20 minutos en efectuarse guardo la nueva base de datos filtrada para en un futuro solamente leerla y utilizarla. Al final, el código queda de la siguiente manera.

\begin{minted}{julia}
using CSV, DataFrames, StatsBase, GLM, Random, CategoricalArrays

# Equivalente a set.seed
Random.seed!(99)

#Leer la base de datos (toma alrededor de 4 minutos en cargar)
personas = CSV.read("Personas00.csv", DataFrame)

# Las columnas que estoy seleccionando para el ajuste
col_sel = ["ID_PERSONA","ENT","SEXO", "EDAD", "NIVACAD", "ALFABET", 
            "INGTRMEN","HORTRA", "CONACT", "SITTRA", "ENT_PAIS_TRAB",
        "AGUINALDO", "VACACIONES", "SERVICIO_MEDICO", "UTILIDADES", "INCAP_SUELDO", "SAR_AFORE", "CREDITO_VIVIENDA"]
# Selecciono solo las columnas del ajuste
personas_filt = personas[:, col_sel]    

# # # FILTRO 1
cond_act = [10, 13, 14, 15, 16, 17, 18, 19, 20]
personas_filt = subset(personas_filt, :CONACT => ByRow(in(cond_act)), skipmissing = true)

# # # FILTRO 2
personas_filt = subset(personas_filt, :ENT_PAIS_TRAB => ByRow(<(33)), skipmissing = true)

personas_filt = subset(personas_filt, :ENT => ByRow(<(33)), skipmissing = true)

# # # FILTRO 3
personas_filt = subset(personas_filt, :HORTRA => ByRow(!=(999)), skipmissing = true)

personas_filt = subset(personas_filt, :INGTRMEN => ByRow(!=(999999)), skipmissing = true)

# # # FILTRO 4
function diferente_a(dataframe, columna, condicion)
    dataframe = subset(dataframe, columna => ByRow(!=(condicion)), skipmissing = true)
    return dataframe
end

categorias_9 = ["SEXO", "AGUINALDO", "VACACIONES", "SERVICIO_MEDICO", "UTILIDADES", 
    "INCAP_SUELDO", "SAR_AFORE", "CREDITO_VIVIENDA", "ALFABET", "SITTRA"]

categorias_99 = ["NIVACAD"]

for i = 1:length(categorias_9)
    personas_filt = diferente_a(personas_filt, categorias_9[i], 9)
end

for i = 1:length(categorias_99)
    personas_filt = diferente_a(personas_filt, categorias_99[i], 99)
end

# Finalmente, guardo el nuevo dataframe
CSV.write("personas_filtradas.csv", personas_filt)
\end{minted}


\section{Regresiones}
\valinline{No estoy segura de como ponerle de nombre a esta seccion}

Lo primero que debemos notar es que la mayoría de las variables que use en mi regresión son categóricas. En este caso, Julia identifica la mayoría de la columnas como tipo \texttt{Int64} en vez de \texttt{Categorical}. Por tanto, hay que transformar los datos que lo necesiten. 

\begin{minted}{julia}
using DataFrames
data = CSV.read("personas_filtradas.csv", DataFrame)

# Vector con todas las categorias
vector_categorias = ["SEXO", "AGUINALDO", "VACACIONES", "SERVICIO_MEDICO", "UTILIDADES", 
    "ALFABET", "NIVACAD", "ENT_PAIS_TRAB", "ENT", "SITTRA"]

transform!(data, names(data, vector_categorias) .=> categorical, renamecols=false)
\end{minted}

Es muy importante no saltarse este paso ya que de lo contrario, la regresión no estará bien hecha. 

Teniendo siempre en mente que el objetivo de esta tesis es probar los límites de Julia, tome la ecuación \ref{modelo_final} y le quité de algunas variables. Se podría pensar como que tomé diferentes subconjuntos de variables y los puse en la regresión para ver si cambiaba la precisión del ajuste. La variable de respuesta siempre es la misma en todos los \textit{sub-ajustes}.


Para el primer \textit{sub-ajuste} tome las primeras 5 variables de la ecuación \ref{modelo_final} y lo llamé \textsf{fit5} (ya que tiene 5 regresores). Es decir, la ecuación \textsf{fit5} es 

\begin{equation*}
    \begin{aligned}
    ingresos \sim horas_{trabajadas} + sexo + edad + escolaridad + entidad_{residencia}
    \end{aligned}
\end{equation*}


El segundo \textit{sub-ajuste} llamado \textsf{fit6} tiene los mismos 5 regresores que \textsf{fit5} más uno extra, la posición laboral. Por eso, la ecuación \textsf{fit6} es 

\begin{equation*}
    \begin{aligned}
    ingresos \sim horas_{trabajadas} + sexo + edad + escolaridad + entidad_{residencia} + posicion_{laboral}
    \end{aligned}
\end{equation*}

Es importante notar que las ecuación \textsf{fit5} y \textsf{fit6} siguen el mismo orden que \ref{modelo_final}. Esto no es una coincidencia. El orden de los regresores en la ecuación \ref{modelo_final} está pensado precisamente para que cada variable sumada se agregue al conjunto de variables anterior y creé una nueva ecuación \textsf{fit}.


\subsection{Observaciones}
Saemos que no es lo mismo hacer un ajuste con 5 observaciones a hacer uno con 5 millones de observaciones. Hay diferencias en tiempo, precisión y credibilidad. Por tanto, continuando con el objetivo principal, cada una de las ecuaciones \textsf{fit} la probe con 500, 5 mil, 50 mil, 500 mil y 2.5 millones de observaciones. Es decir, use cada una de las ecuaciones \textsf{fit} para ajustar un modelo con las 5 cantidades de observaciones antes mencionadas. Es importante señalar que las observaciones se seleccionan al azar usando el comando \textsf{sample}. Una vez seleccionadas, guardaba el dataframe generado para usar exactamente los mismos datos en \textsf{R} y \textsf{Python}. 


Finalmente, para hacer que todo funcione más rápido, hice una funció para cada \textsf{fit}. Las funciones para cada \textsf{fit} son casi iguales a excepción de la fórmula que se necesita para el ajuste y el nombre con el que guardo los resultados. Fue importante para mí hacer una función para cada ecuación \textsf{fit} ya que creo esencial que laa fórmula que se usa en el ajuste esté puesta de manera explícita. 


Ya que las funciones y su aplicación son muy similares, solamente mostraré las funciones para \textsf{fit5} y para \textsf{fit10} como ejemplo. 

El código para \textsf{fit5} es el siguiente. 

\begin{minted}{julia}
### FIT BASE ###
function fit5(cantidad_sample, nombre_facil)
    nombre_fit = "fit5"
    
    sample_rows = sample(1:nrow(data), cantidad_sample, replace=false)

    df_sample = data[sample_rows, :]
    
    nombre_completo = nombre_facil*"_"*nombre_fit*".csv"
    # Guardamos el documentos para usarlo en R
    CSV.write(nombre_completo, df_sample)

    # Hacemos el fit
    sample_fit = lm(@formula(INGTRMEN ~ HORTRA + SEXO + EDAD + NIVACAD + ENT_PAIS_TRAB), df_sample)

    aux = "res_"
    nombre_completo = aux*nombre_completo
    CSV.write(nombre_completo, coeftable(sample_fit))
end 

# Aplicamos la función para las observaciones
fit5(500, "500")
fit5(5000, "5mil")
fit5(50000, "50mil")
fit5(500000, "500mil")
fit5(2500000, "2500mil")

\end{minted}

El código para \textsf{fit10} es el siguiente. 

\begin{minted}{julia}
### FIT 10###
function fit10(cantidad_sample, nombre_facil)
    nombre_fit = "fit10"
    
    sample_rows = sample(1:nrow(data), cantidad_sample, replace=false)

    df_sample = data[sample_rows, :]
    
    nombre_completo = nombre_facil*"_"*nombre_fit*".csv"
    # Guardamos el documentos para usarlo en R
    CSV.write(nombre_completo, df_sample)

    # Hacemos el fit
    sample_fit = lm(@formula(INGTRMEN ~ HORTRA + SEXO + EDAD + NIVACAD + ENT_PAIS_TRAB
            + SITTRA + ALFABET + AGUINALDO + VACACIONES + SERVICIO_MEDICO), df_sample)

    aux = "res_"
    nombre_completo = aux*nombre_completo
    CSV.write(nombre_completo, coeftable(sample_fit))
end 

# Fit 10: Fit 5 + SITTRA + ALFABET + AGUINALDO + VACACIONES + SERVICIO_MEDICO
fit10(500, "500")
fit10(5000, "5mil")
fit10(50000, "50mil")
fit10(500000, "500mil")
fit10(2500000, "2500mil")

\end{minted}

\section{Resultados}
No tengo idea de como poner los resultados. Lit, ni idea.

