\chapter{Conclusiones}

El objetivo de este trabajo fue mostrar las capacidades de tres lenguajes de programación: \textsf{Julia}, \textsf{R} y \textsf{Python}. El documento se divide en dos partes. En la primera parte, se presenta una introducción a cada lenguaje utilizado. Cabe destacar que este documento no pretende ser un manual de ningún lenguaje. En el capítulo de \textsf{Julia} se agregaron los pasos de instalación así como la definición de objetos básicos bajo el entendimiento de que este es el lenguaje menos conocido. En los capítulos de \textsf{R} y \textsf{Python} se asume que el lector está más familiarizado con estos lenguajes por lo que se presentan los paquetes utilizados en este trabajo.  En suma, el objetivo de esta parte del documento es proporcionar las herramientas necesarias para entender el código presentado en la segunda parte. 

En la segunda parte de este trabajo se presentan tres ejemplos cuyo objetivo es señalar diferentes aspectos de los lenguajes. En el primer ejercicio se trabajó con un problema propuesto por NIST donde se busca hacer el ajuste de un polinomio de grado 10. De manera intencional, el sistema lineal del problema está mal condicionado lo que genera dificultades al calcular la solución. Así, el objetivo de este ejercicio es medir la precisión numérica presentada por los lenguajes. 

En \textsf{Julia} se realizaron cuatro intentos de solución al problema donde dos de ellos utilizan teoría algebraica mientras los restantes emplean funciones de paquetes ya programados. De las cuatro manera de solución, solamente una obtuvo los resultados correctos. En \textsf{R} se utilizó la solución publicada por Brian Ripley donde se emplea la función \texttt{lm} con un cambio en el argumento de tolerancia. Por último, en \textsf{Python} se utilizó la función \texttt{polyfit} del paquete \texttt{NumPy} con la cual el cálculo de la solución fue preciso sin necesidad de ningún ajuste a la función. 

El segundo ejemplo consistió en realizaron el ajuste de una regresión lineal múltiple a una base de datos extensa. Los datos utilizados se tomaron del Censo 2020 realizado por el INEGI. Se crearon 5 modelos que buscaban relacionar los ingresos de una persona con variables que pudieran tener un efecto en la suma remunerada. Se comenzó con un modelo con 5 regresores y se fue agregando 1 regresor en la creación del modelo nuevo. Además, se tomaron 5 volúmenes de datos diferentes, comenzando con una muestra de 500 observaciones y aumentando la cantidad hasta llegar a 2.5 millones de datos. En total, en este ejemplo se hicieron 25 ajustes diferentes. 

El objetivo de este ejemplo fue observar el manejo de grandes cantidades de datos en cada uno de los lenguajes. \textsf{Julia} presenta la misma rapidez que \textsf{Python} en el cálculo del ajuste. Sin embargo, la rapidez de \textsf{Python} al generar archivos de resultados sobrepasa de gran manera a \textsf{Julia}. Por otro lado, \textsf{R} presenta un manejo de datos lento y entorpecido por el constante reinicio de sesión. Sin embargo, los tres lenguajes presentaron el cálculo de los resultados de manera correcta y precisa. 

El tercer ejemplo pertenece a la rama del diseño de experimentos. Se tomó el artículo publicado por \cite{meyer1996} donde se presentan los pasos para hacer un estudio de los resultados de un experimento. La metodología comienza con un análisis bayesiano que busca elegir los factores que afectan la variable de respuesta. Se presenta el caso donde no hay una distinción clara entre los factores activos y no activos durante el experimento por lo que Meyer propone el criterio MD, de \textit{Model Discrimination}. Este criterio busca seleccionar algunas ensayos extras necesarios para determinar que factores afectan a la variable de respuesta y poder así, elegir el mejor modelo que describa al experimento. 

Este ejemplo presenta una alta complejidad e intensidad en cálculos. En \textsf{R}, se utilizó el paquete \texttt{BsMD2} creado por Patricia Vela. Este paquete contiene la función \texttt{MDopt} que hace el cálculo del criterio MD. Esta función se programó en \textsf{Julia} y \textsf{Python} para posteriormente, unir los tres lenguajes en \textsf{R}. Es decir, se programó la función \texttt{MDopt} en \textsf{Julia} y en \textsf{Python}. Después, se utilizaron los paquetes \texttt{JuliaCall} y \texttt{reticulate} para importar dichas funciones en \textsf{R}. De esta forma, se obtuvo una comparación en los tiempos de ejecución donde \textsf{Julia} muestra toda su capacidad computacional y logra ejecutar el algoritmo más rápido que los otros lenguajes. 

En mi opinión, \textsf{Julia} no busca ser la copia de \textsf{R} o \textsf{Python} en análisis y manejo de datos. \textsf{Julia} está hecho para ser un lenguaje que realiza simulaciones y cálculos complejos con un alto rendimiento. \textsf{Julia} tiene mucho que ofrecer incluyendo un análisis de datos fácil e intuitivo. Sin embargo, su uso va más allá y sus aplicaciones incluyen modelos de estadística bayesiana, análisis epistemológicos y análisis de sistemas dinámicos. 

Una extensión de esta tesis podría estar enfocada en elaborar un manual formal que presente una lista extensa de ejercicios resueltos en los tres lenguajes. Deben tener diversos objetivos y estar enofcados en distintas áreas de conocimiento para notar paquetes y funciones análogos en lenguajes. Otra posible extensión de este trabajo sería el desarrollo de un paquete análogo a \texttt{BsMD2} donde se creen funciones que permitan la aplicación de la metodología completa propuesta por Meyer para el diseño de experimentos. 





