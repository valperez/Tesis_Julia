\chapter{Conclusiones} \label{cap_conclusiones}
Uno de los objetivos de este trabajo de tesis es mostrar algunas de las capacidades de tres lenguajes de cómputo estadístico: \textsf{Julia}, \textsf{R} y \textsf{Python}. El documento se divide en dos partes. En la primera parte, se hace una breve descripción de cada lenguaje utilizado sin pretender ser un manual. En el capítulo \ref{cap_julia} de \textsf{Julia}, por ser el lenguaje más novedoso, se mencionan los pasos iniciales desde la instalación hasta la definición de objetos básicos. En los capítulos \ref{cap_python} y \ref{cap_R}, de \textsf{Python} y \textsf{R} respectivamente, se asume que el lector está más familiarizado con estos lenguajes por lo que se presentan directamente los paquetes utilizados en este trabajo.  

En la segunda parte del trabajo se presentan tres distintos proyectos para mostrar los desempeños de los lenguajes. El primer proyecto es un problema retador numéricamente. Se trabajó con un problema propuesto por NIST donde se busca hacer el ajuste de un polinomio de grado 10 con 82 observaciones. De manera intencional, el sistema lineal asociado está mal condicionado lo que genera dificultades al calcular la solución. Así, el objetivo de este ejercicio es medir la precisión numérica presentada por los lenguajes. 

En \textsf{Julia} se realizaron cuatro intentos de solución al problema donde dos de ellos utilizan teoría algebraica mientras los restantes emplean funciones de paquetes ya programados. De las cuatro manera de solución, solamente una obtuvo los resultados correctos. En \textsf{R} se utilizó la solución sugerida por Brian Ripley donde se emplea la función \texttt{lm} con un cambio en el argumento de tolerancia. Por último, en \textsf{Python} se utilizó la función \texttt{polyfit} del paquete \texttt{NumPy} con la cual el cálculo de la solución fue preciso sin necesidad de ningún ajuste a la función. 

El segundo proyecto consiste en el ajuste de modelos de regresión lineal múltiple a una base de datos extensa. Los datos utilizados se tomaron del Censo 2020 realizado por el INEGI. Para propósito de desempeño, y no de análisis, se crearon 5 modelos que buscaban relacionar los ingresos de una persona con variables que pudieran tener un efecto en la suma remunerada. Se comenzó con un modelo con 5 regresores y se fue agregando 1 regresor en la creación del modelo nuevo. Además, se tomaron 5 volúmenes de datos diferentes, comenzando con una muestra de 500 observaciones y aumentando la cantidad hasta llegar a 2.5 millones de datos. En total, para este proyecto se construyeron 25 ajustes diferentes. 

El objetivo de este ejemplo fue observar el manejo de grandes cantidades de datos en cada uno de los lenguajes. \textsf{Julia} presenta la misma rapidez que \textsf{Python} en el cálculo del ajuste. Sin embargo, la rapidez de \textsf{Python} al generar archivos de resultados sobrepasa de gran manera a \textsf{Julia}. Por otro lado, \textsf{R} presenta un manejo de datos lento y entorpecido por el constante reinicio de sesión. Sin embargo, los tres lenguajes presentaron el cálculo de los resultados de manera correcta y precisa. 

El tercer ejemplo pertenece a la rama del diseño de experimentos. Se tomó el artículo publicado por \cite{meyer1996} donde se presentan los pasos para hacer un estudio de los resultados de un experimento. La metodología comienza con un análisis bayesiano que busca elegir los factores que afectan la variable de respuesta. La particularidad crucial de este ejemplo es que no hay distinción clara en los factores activos y no activos del experimento. Por lo tanto, Meyer propone el criterio MD, de \textit{Model Discrimination}. El criterio busca seleccionar algunas ensayos extras necesarios para determinar que factores afectan a la variable de respuesta y poder así, elegir el mejor modelo que describa al experimento. 

El proyecto presenta una alta complejidad e intensidad en cálculos. En \textsf{R}, se utilizó el paquete \texttt{BsMD2} creado por Patricia Vela que aborda el problema con la función \texttt{MDopt} que hace el cálculo del criterio MD. Esta función se programó en \textsf{Julia} y \textsf{Python} para posteriormente, unir los tres lenguajes en \textsf{R}. Es decir, se programó la función \texttt{MDopt} en \textsf{Julia} y en \textsf{Python}. Después, se utilizaron los paquetes \texttt{JuliaCall} y \texttt{reticulate} para importar dichas funciones en \textsf{R}. De esta forma, se obtuvo una comparación en los tiempos de ejecución donde \textsf{Julia} muestra toda su capacidad computacional y logra ejecutar el algoritmo más rápido que los otros lenguajes. 

En mi opinión, \textsf{Julia} no busca ser la copia de \textsf{R} o \textsf{Python} en análisis y manejo de datos. \textsf{Julia} está hecho para ser un lenguaje que realiza simulaciones y cálculos complejos con un alto rendimiento. \textsf{Julia} tiene mucho que ofrecer incluyendo un análisis de datos fácil e intuitivo. Sin embargo, su uso va más allá y sus aplicaciones incluyen modelos de estadística bayesiana, análisis epistemológicos y análisis de sistemas dinámicos. 

Una extensión de esta tesis podría ser la estandarización de las pruebas realizadas para su ejecución en otros lenguajes. De esta manera, se podría obtener una comparación con más lenguajes y determinar que lenguaje es el más rápido. Otro posible camino de mejora es probar los proyectos presentados en este trabajo en diferentes arquitecturas. Es decir, cambiar de procesadores, marca del ordenador en el que se trabaja, e incluso de sistema operativo. Sería interesante observar el cambio en los tiempos de ejecución y en la aplicación de las pruebas. Finalmente, se podría ampliar este trabajo eligiendo y utilizando distintos paquetes que también se enfoquen en modelos de regresión y diseño de experimentos. 





